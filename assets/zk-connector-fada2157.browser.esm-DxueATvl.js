import{y as x,_ as I,q as S,t as G,al as o,n as l,c$ as T,K as P,d0 as v,bw as d,c8 as w,d1 as E,d2 as F}from"./index-BnY9_9DF.js";import{H as b}from"./http-rpc-client-0a079e80.browser.esm-bGXAR1w5.js";import{i as C,h as A}from"./thirdweb-dev-wallets.browser.esm-BFH8dPxt.js";import"./url-a45219bd.browser.esm-De7l7Dgd.js";import"./normalizeChainId-1fb9aedf.browser.esm-Dulsj_Qd.js";import"./index-C-NWtsoG.js";const u=5e4,g=113,D={Transaction:[{name:"txType",type:"uint256"},{name:"from",type:"uint256"},{name:"to",type:"uint256"},{name:"gasLimit",type:"uint256"},{name:"gasPerPubdataByteLimit",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymaster",type:"uint256"},{name:"nonce",type:"uint256"},{name:"value",type:"uint256"},{name:"data",type:"bytes"},{name:"factoryDeps",type:"bytes32[]"},{name:"paymasterInput",type:"bytes"}]};class y extends S{constructor(e,t){super(),this.signer=e,G.defineReadOnly(this,"provider",e.provider),this.httpRpcClient=t}async getAddress(){return await this.signer.getAddress()}async signMessage(e){return await this.signer.signMessage(e)}async signTransaction(e){return await this.signer.signTransaction(e)}connect(e){return new y(this.signer.connect(e),this.httpRpcClient)}_signTypedData(e,t,r){return this.signer._signTypedData(e,t,r)}async sendTransaction(e){return await this.sendZkSyncTransaction(e)}async sendZkSyncTransaction(e){let t=await this.populateTransaction(e);if(!t.chainId)throw new Error("ChainId is required to send a ZkSync transaction");if(!this.provider)throw new Error("Provider is required to send a ZkSync transaction");const r=await this.getAddress(),m=o.from(t.gasLimit||await this.provider.estimateGas(t)).mul(3),s=o.from(t.gasPrice||await this.provider.getGasPrice()).mul(2);t.maxFeePerGas?t.maxFeePerGas=t.maxFeePerGas.mul(2):t.maxFeePerGas=s,t.maxPriorityFeePerGas?t.maxPriorityFeePerGas=t.maxPriorityFeePerGas.mul(2):t.maxPriorityFeePerGas=s,t={...t,from:r,gasLimit:m,gasPrice:s,chainId:(await this.provider.getNetwork()).chainId,nonce:await this.provider.getTransactionCount(r),type:113,value:BigInt(0)};const n=await this.httpRpcClient?.zkPaymasterData(t);t.customData={gasPerPubdata:u,factoryDeps:[],paymasterParams:{paymaster:n.paymaster,paymasterInput:n.paymasterInput}};const c={txType:g,from:BigInt(t.from||await this.getAddress()).toString(),to:BigInt(t.to||"0x0").toString(),gasLimit:t.gasLimit?Number(t.gasLimit):0,gasPerPubdataByteLimit:u,maxFeePerGas:o.from(t.maxFeePerGas).toNumber(),maxPriorityFeePerGas:o.from(t.maxPriorityFeePerGas).toNumber(),paymaster:BigInt(n.paymaster).toString(),nonce:o.from(t.nonce).toNumber(),value:o.from(t.value).toNumber(),data:t.data||"0x",factoryDeps:[],paymasterInput:l(n.paymasterInput)},a=await this._signTypedData({name:"zkSync",version:"2",chainId:t.chainId},D,c),i=this.serialize(t,a),p={from:t.from?.toString()||await this.getAddress(),to:t.to?.toString()||"",gas:t.gasLimit?.toString()||"",maxFeePerGas:t.maxFeePerGas?.toString()||"0",maxPriorityFeePerGas:t.maxPriorityFeePerGas?.toString()||"0",signedTransaction:i,paymaster:n.paymaster},f=(await this.httpRpcClient?.zkBroadcastTransaction(p)).transactionHash;return await this.provider?.getTransaction(f)}serialize(e,t){if(!e.customData&&e.type!==g)return T(e,t);if(!e.chainId)throw Error("Transaction chainId isn't set!");function r(i,p){const h=d(o.from(i).toHexString());if(h.length>32)throw new Error(`Invalid length for ${p}!`);return h}if(!e.from)throw new Error("Explicitly providing `from` field is required for EIP712 transactions!");const m=e.from,s=e.customData??{},n=e.maxFeePerGas||e.gasPrice||0,c=e.maxPriorityFeePerGas||n,a=[r(e.nonce||0,"nonce"),r(c,"maxPriorityFeePerGas"),r(n,"maxFeePerGas"),r(e.gasLimit||0,"gasLimit"),e.to?P(e.to):"0x",r(e.value||0,"value"),e.data||"0x"];if(t){const i=v(t);a.push(r(i.recoveryParam,"recoveryParam")),a.push(d(i.r)),a.push(d(i.s))}else a.push(r(e.chainId,"chainId")),a.push("0x"),a.push("0x");if(a.push(r(e.chainId,"chainId")),a.push(P(m)),a.push(r(s.gasPerPubdata||u,"gasPerPubdata")),a.push((s.factoryDeps??[]).map(i=>w(i))),s.customSignature&&l(s.customSignature).length===0)throw new Error("Empty signatures are not supported!");return a.push(s.customSignature||"0x"),s.paymasterParams?a.push([s.paymasterParams.paymaster,w(s.paymasterParams.paymasterInput)]):a.push([]),E([[g],F(a)])}}class M extends x{constructor(e){super(),I(this,"chainId",1),this.config=e}async connect(e){if(this.personalWallet=e.personalWallet,this.chainId=await(await this.personalWallet.getSigner()).getChainId(),!await C(this.chainId))throw new Error("Invalid zksync chain id");const t=this.config.bundlerUrl||`https://${this.chainId}.bundler.thirdweb.com`,r=this.config.entryPointAddress||A;return this.httpRpcClient=new b(t,r,this.chainId,this.config.clientId,this.config.secretKey),this.getAddress()}disconnect(){throw new Error("Method not implemented.")}async getAddress(){return(await this.getSigner()).getAddress()}async getSigner(){if(!this.personalWallet)throw new Error("Wallet not connected");return new y(await this.personalWallet.getSigner(),this.httpRpcClient)}switchChain(e){throw new Error("Method not implemented.")}isConnected(){return Promise.resolve(!!this.personalWallet)}setupListeners(){throw new Error("Method not implemented.")}updateChains(e){throw new Error("Method not implemented.")}async getProvider(){if(!this.getSigner())throw new Error("Personal wallet not connected");const e=await this.getSigner();if(!e.provider)throw new Error("Provider not found");return e.provider}}export{M as ZkSyncConnector};
