import{aQ as T,aN as n,cp as _,cq as M,h as D,bg as A,K as H}from"./index-BnY9_9DF.js";import{s as G,a as N,b}from"./index-B48giIwZ.js";import"./index-CnX2YvtY.js";import"./index-HBOtwn9K.js";import"./index-DcmhNLSm.js";const f={1:"https://safe-transaction-mainnet.safe.global",11155111:"https://safe-transaction-sepolia.safe.global",10:"https://safe-transaction-optimism.safe.global",56:"https://safe-transaction-bsc.safe.global",100:"https://safe-transaction-gnosis-chain.safe.global",137:"https://safe-transaction-polygon.safe.global",43114:"https://safe-transaction-avalanche.safe.global",42161:"https://safe-transaction-arbitrum.safe.global",42220:"https://safe-transaction-celo.safe.global",8453:"https://safe-transaction-base.safe.global",1313161554:"https://safe-transaction-aurora.safe.global",1101:"https://safe-transaction-zkevm.safe.global",324:"https://safe-transaction-zksync.safe.global"},k={1:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",137:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",56:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",42161:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",1313161554:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",43114:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",10:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",42220:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",100:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",11155111:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",8453:"0x98FFBBF51bb33A056B08ddf711f289936AafF717",1101:"0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",324:"0x357147caf9C0cCa67DfA0CF5369318d8193c8407"},L=[{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"msgHash",type:"bytes32"}],name:"SignMsg",type:"event"},{inputs:[{internalType:"bytes",name:"message",type:"bytes"}],name:"getMessageHash",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes",name:"_data",type:"bytes"}],name:"signMessage",outputs:[],stateMutability:"nonpayable",type:"function"}];class d extends T{constructor(){super(),n(this,"supportedChains",d.supportedChains),n(this,"id","safe-wallet"),n(this,"ready",!0),n(this,"name","Safe Wallet"),this.ready=!0}async connect(e){if(!(e.chain.chainId in f))throw new Error("Chain not supported by Safe");return this.safeSigner=await this.createSafeSigner(e),await this.getAddress()}async createSafeSigner(e){this.personalWallet=e.personalWallet;const a=await e.personalWallet.getSigner(),h=e.safeAddress,r=e.chain.chainId;if(!a)throw new Error("cannot create Gnosis Safe signer without a personal signer");if(await a.getChainId()!==r)throw new Error("chainId of personal signer has to match safe chainId");if(!h)throw new Error("safeAddress is required");if(!r)throw new Error("safeChainId is required");const g=f[r],i=k[r];if(!g||!i)throw new Error("Chain not supported");const u=new G({ethers:_,signerOrProvider:a}),t=await N.create({ethAdapter:u,safeAddress:h}),o=new b.SafeService(g),p=new b.SafeEthersSigner(t,o,a.provider);return p.signMessage=async w=>{const y=new M(i,L).interface.encodeFunctionData("signMessage",[D(w)]),S=i,F="0",B=1,C=5e4,m=5e4,x=0,I=A,v=A,l=await t.createTransaction({safeTransactionData:{to:S,value:F,operation:B,data:y,baseGas:m,safeTxGas:C,gasPrice:x,gasToken:I,refundReceiver:v}}),c=await t.getTransactionHash(l),E=await t.signTransactionHash(c);for(await o.proposeTx(t.getAddress(),c,l,E);;){try{const s=await o.getSafeTxDetails(c);if(s.transactionHash){await a.provider?.waitForTransaction(s.transactionHash);break}}catch{}await new Promise(s=>setTimeout(s,5e3))}return"0x"},this.previousConnector=e.personalWallet,p}async disconnect(){this.safeSigner=void 0,this.previousConnector=void 0}async getAddress(){return await(await this.getSigner()).getAddress()}async getChainId(){return(await this.getSigner()).getChainId()}async getProvider(){const e=(await this.getSigner()).provider;if(!e)throw new Error("No provider available");return e}async getSigner(){if(!this.safeSigner)throw new Error("not connected - please call connect() first");return this.safeSigner}async isConnected(){try{return!!await this.getAddress()}catch{return!1}}onAccountsChanged(e){e.length===0?this.emit("disconnect"):e[0]&&this.emit("change",{account:H(e[0])})}onDisconnect(){this.emit("disconnect")}switchChain(){throw new Error("Safe connector does not support switching chains")}updateChains(){}async setupListeners(){}}n(d,"supportedChains",Object.keys(f));export{d as SafeConnector};
