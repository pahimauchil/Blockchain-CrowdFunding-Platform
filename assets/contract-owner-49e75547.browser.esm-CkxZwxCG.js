import{aA as P,b7 as w,a1 as h,ax as B,a2 as y,aE as k,ao as N,ag as C,b8 as b,b9 as v,ba as D,al as F,a as M,C as x,bb as L,bc as W}from"./index-BnY9_9DF.js";import{h as m}from"./contract-appuri-5c40af52.browser.esm-DXar0voT.js";import{C as U}from"./setErc20Allowance-7f76f677.browser.esm-DlAvhW79.js";import{g as A,f as S}from"./QueryParams-32a56510.browser.esm-D4k8iEeb.js";import{a as O}from"./index-DCSju942.js";class K{featureName=P.name;constructor(t,a){this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){const[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return w.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){const[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return w.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}setDefaultRoyaltyInfo=h(async t=>{const a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),r=await this.metadata._parseAndUploadMetadata(e);if(m("setContractURI",this.contractWrapper)){const o=new B(this.contractWrapper),n=[o.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),o.encode("setContractURI",[r])];return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:l=>({receipt:l,data:()=>this.getDefaultRoyaltyInfo()})})}else throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")});setTokenRoyaltyInfo=h(async(t,a)=>{const e=w.parse(a);return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:r=>({receipt:r,data:()=>this.getDefaultRoyaltyInfo()})})})}class ${constructor(t,a,e,r){this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}createDelayedRevealBatch=h(async(t,a,e,r)=>{if(!e)throw new Error("Password is required");const o=await this.storage.uploadBatch([U.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),n=A(o),l=await this.nextTokenIdToMintFn(),c=await this.storage.uploadBatch(a.map(p=>U.parse(p)),{onProgress:r?.onProgress,rewriteFileNames:{fileStartNumber:l.toNumber()}}),s=A(c),i=await this.contractWrapper.read("getBaseURICount",[]),I=await this.hashDelayRevealPassword(i,e),R=await this.contractWrapper.read("encryptDecrypt",[C(s),I]);let g;if(await this.isLegacyContract())g=R;else{const p=await this.contractWrapper.getChainID(),u=b(["bytes","bytes","uint256"],[C(s),I,p]);g=v.encode(["bytes","bytes32"],[R,u])}return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[c.length,n.endsWith("/")?n:`${n}/`,g],parse:p=>{const u=this.contractWrapper.parseLogs("TokensLazyMinted",p?.logs),E=u[0].args.startTokenId,T=u[0].args.endTokenId,_=[];for(let f=E;f.lte(T);f=f.add(1))_.push({id:f,receipt:p});return _}})});reveal=h(async(t,a)=>{if(!a)throw new Error("Password is required");const e=await this.hashDelayRevealPassword(t,a);try{const r=await this.contractWrapper.callStatic().reveal(t,e);if(!r.includes("://")||!r.endsWith("/"))throw new Error("invalid password")}catch{throw new Error("invalid password")}return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})});async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map(s=>{if(m("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[s]);if(m("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[s]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),r=e.slice(0,e.length-1),o=await Promise.all(Array.from([0,...r]).map(s=>this.getNftMetadata(s.toString()))),n=await this.isLegacyContract(),c=(await Promise.all(Array.from([...e]).map(s=>n?this.getLegacyEncryptedData(s):this.contractWrapper.read("encryptedData",[s])))).map(s=>D(s)>0?n?s:v.decode(["bytes","bytes32"],s)[0]:s);return o.map((s,i)=>({batchId:F.from(i),batchUri:s.uri,placeholderMetadata:s})).filter((s,i)=>D(c[i])>0)}async hashDelayRevealPassword(t,a){const e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return b(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return S(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if(m("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch{return!1}return!1}async getLegacyEncryptedData(t){const a=(await M(async()=>{const{default:o}=await import("./IDelayedRevealDeprecated-JM0269jw.js");return{default:o}},[])).default,r=await new x(this.contractWrapper.address,a,this.contractWrapper.getProvider()).functions.encryptedBaseURI(t);return r.length>0?r[0]:"0x"}}async function j(d,t,a,e,r){let o={};const n=e||W,c=(await L(d.getProvider(),t,n)).mul(a);return c.gt(0)&&(n===W?o={value:c}:n!==W&&r&&await O(d,n,c,a,0)),o}class G{featureName=k.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=h(async t=>{const a=await N(t);return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})})}export{K as C,$ as D,G as a,j as c};
