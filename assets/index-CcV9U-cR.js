const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BFJltGNr.js","assets/index-BK-I7xHM.css"])))=>i.map(i=>d[i]);
import{c3 as ee,c4 as p,ap as M,as as z,au as Y,bz as I,c5 as le,bg as B,bc as $,bZ as g,bG as fe,al as C,bt as v,bH as N,c6 as te,aq as ce,b2 as j,by as V,bb as re,c0 as he,b_ as pe,c2 as J,c7 as de,c8 as K,ag as me,c9 as Q,ca as R,cb as ye,cc as ge,b8 as X,bA as be,cd as F,ce as we,a as Se,aw as Te,a$ as xe,cf as Pe,cg as Be}from"./index-BFJltGNr.js";import{r as Ae,a as Ie}from"./treeify-DCxxtX2w.js";import{E as Ce,S as se}from"./assertEnabled-d1700f0b.browser.esm-Du5v_594.js";import{N as U}from"./setErc20Allowance-7f76f677.browser.esm-C2WcXHxg.js";var ke=Ae();const P=ee(ke);var Le=Ie();class S{print(){S.print(this)}bufferIndexOf(e,t){if(arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1)return this.binarySearch(e,t,p.Buffer.compare);const s=(n,u)=>n.equals(u);return this.linearSearch(e,t,s)}static binarySearch(e,t,r){let s=0,n=e.length-1;for(;s<=n;){const u=Math.floor((s+n)/2),i=r(e[u],t);if(i===0){for(let o=u-1;o>=0;o--)if(r(e[o],t)!==0)return o+1;return 0}else i<0?s=u+1:n=u-1}return-1}binarySearch(e,t,r){return S.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let s=0;s<e.length;s++)if(r(e[s],t))return s;return-1}linearSearch(e,t,r){return S.linearSearch(e,t,r)}static bufferify(e){if(!p.Buffer.isBuffer(e)){if(typeof e=="object"&&e.words)return p.Buffer.from(e.toString(ve),"hex");if(S.isHexString(e))return p.Buffer.from(e.replace(/^0x/,""),"hex");if(typeof e=="string")return p.Buffer.from(e);if(typeof e=="bigint")return p.Buffer.from(e.toString(16),"hex");if(e instanceof Uint8Array)return p.Buffer.from(e.buffer);if(typeof e=="number"){let t=e.toString();return t.length%2&&(t=`0${t}`),p.Buffer.from(t,"hex")}else if(ArrayBuffer.isView(e))return p.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return S.bigNumberify(e)}static bigNumberify(e){if(typeof e=="bigint")return e;if(typeof e=="string")return e.startsWith("0x")&&S.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(p.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return Ne(e);if(typeof e=="number")return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return typeof e=="string"&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return S.bufferToHex(e,t)}static bufferToHex(e){return`${(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0)?"0x":""}${(e||p.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return S.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);if(p.Buffer.isBuffer(r))return r;if(this.isHexString(r))return p.Buffer.from(r.replace("0x",""),"hex");if(typeof r=="string")return p.Buffer.from(r);if(typeof r=="bigint")return p.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(r))return p.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const s=He(t.toString("hex")),n=e(s),u=Ee(n);return p.Buffer.from(u,"hex")}}isHexString(e){return S.isHexString(e)}log2(e){return e===1?0:1+this.log2(e/2|0)}zip(e,t){return e.map((r,s)=>[r,t[s]])}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var Oe=S;function ve(a){const e=a.words,t=new ArrayBuffer(e.length*4),r=new Uint8Array(t);for(let s=0;s<e.length;s++)r[s*4]=e[s]>>24&255,r[s*4+1]=e[s]>>16&255,r[s*4+2]=e[s]>>8&255,r[s*4+3]=e[s]&255;return t}function He(a){const e=new Uint8Array(a.length/2);for(let t=0;t<a.length;t+=2)e[t/2]=parseInt(a.substring(t,t+2),16);return e.buffer}function Ee(a){const e=new Uint8Array(a);return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}function Ne(a){const e=Array.from(a).map(t=>t.toString(16).padStart(2,"0")).join("");return BigInt(`0x${e}`)}class L extends Oe{duplicateOdd=!1;concatenator=p.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(e,t){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if(typeof r.fillDefaultHash=="function")this.fillDefaultHash=r.fillDefaultHash;else if(p.Buffer.isBuffer(r.fillDefaultHash)||typeof r.fillDefaultHash=="string")this.fillDefaultHash=(s,n)=>r.fillDefaultHash;else throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(p.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&t===1&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let s=0;s<e.length;s+=2){if(s>=r){this.layers[t].push(...e.slice(r));break}else if(s+1===e.length&&e.length%2===1){const l=e[e.length-1];let c=l;if(this.isBitcoinTree){c=this.hashFn(this.concatenator([P(l),P(l)])),c=P(this.hashFn(c)),this.layers[t].push(c);continue}else if(!this.duplicateOdd){this.layers[t].push(e[s]);continue}}const n=e[s],u=s+1===e.length?n:e[s+1];let i=null;this.isBitcoinTree?i=[P(n),P(u)]:i=[n,u],this.sortPairs&&i.sort(p.Buffer.compare);let o=this.hashFn(this.concatenator(i));this.isBitcoinTree&&(o=P(this.hashFn(o))),this.layers[t].push(o)}e=this.layers[t]}}addLeaf(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(p.Buffer.compare))),this.leaves.filter(t=>this.bufferIndexOf(e,t,this.sortLeaves)!==-1)):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?p.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++)if(t[r].equals(e))return r;return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(t=>L.bufferToHex(t)),null,2)}static unmarshalLeaves(e){let t=null;if(typeof e=="string")t=JSON.parse(e);else if(e instanceof Object)t=e;else throw new Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(L.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(r=>this.bufferToHex(r))):e.push(t),e),[])}getLayersFlat(){const e=this.layers.reduce((t,r)=>(Array.isArray(r)?t.unshift(...r):t.unshift(r),t),[]);return e.unshift(p.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return this.layers.length===0?p.Buffer.from([]):this.layers[this.layers.length-1][0]||p.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(typeof e>"u")throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let s=0;s<this.leaves.length;s++)p.Buffer.compare(e,this.leaves[s])===0&&(t=s)}if(t<=-1)return[];for(let s=0;s<this.layers.length;s++){const n=this.layers[s],u=t%2,i=u?t-1:this.isBitcoinTree&&t===n.length-1&&s<this.layers.length-1?t:t+1;i<n.length&&r.push({position:u?"left":"right",data:n[i]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(r=>this.bufferToHex(r.data))}getProofs(){const e=[],t=[];return this.getProofsDFS(this.layers.length-1,0,e,t),t}getProofsDFS(e,t,r,s){const n=t%2;if(e===-1){n||s.push([...r].reverse());return}if(t>=this.layers[e].length)return;const u=this.layers[e],i=n?t-1:t+1;let o=!1;i<u.length&&(o=!0,r.push({position:n?"left":"right",data:u[i]}));const l=t*2,c=t*2+1;this.getProofsDFS(e-1,l,r,s),this.getProofsDFS(e-1,c,r,s),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(r=>[r.position==="left"?0:1,this.bufferToHex(r.data)])}getProofIndices(e,t){const r=2**t;let s=new Set;for(const l of e){let c=r+l;for(;c>1;)s.add(c^1),c=c/2|0}const n=e.map(l=>r+l),u=Array.from(s).sort((l,c)=>l-c).reverse();s=n.concat(u);const i=new Set,o=[];for(let l of s)if(!i.has(l))for(o.push(l);l>1&&(i.add(l),!!i.has(l^1));)l=l/2|0;return o.filter(l=>!e.includes(l-r))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),s=[];for(let i=0;i<r;i++)t%2!==0&&s.push({index:i,leavesCount:t}),t=Math.ceil(t/2);const n=[];let u=e;for(let i=0;i<r;i++){let l=u.map(f=>f%2===0?f+1:f-1).filter(f=>!u.includes(f));const c=s.find(f=>{let{index:h}=f;return h===i});c&&u.includes(c.leavesCount-1)&&(l=l.slice(0,-1)),n.push(l),u=[...new Set(u.map(f=>f%2===0?f/2:f%2===0?(f+1)/2:(f-1)/2))]}return n}getMultiProof(e,t){if(this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat()),this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let s=t;this.sortPairs&&(s=s.sort(p.Buffer.compare));let n=s.map(l=>this.bufferIndexOf(this.leaves,l,this.sortLeaves)).sort((l,c)=>l===c?0:l>c?1:-1);if(!n.every(l=>l!==-1))throw new Error("Element does not exist in Merkle tree");const u=[],i=[];let o=[];for(let l=0;l<this.layers.length;l++){const c=this.layers[l];for(let f=0;f<n.length;f++){const h=n[f],m=this.getPairNode(c,h);u.push(c[h]),m&&i.push(m),o.push(h/2|0)}n=o.filter((f,h,m)=>m.indexOf(f)===h),o=[]}return i.filter(l=>!u.includes(l))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(s=>e[s])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],s=t;for(const n of e){const u=[];for(const o of s){if(o%2===0){const c=o+1;if(!s.includes(c)&&n[c]){u.push(n[c]);continue}}const l=o-1;if(!s.includes(l)&&n[l]){u.push(n[l]);continue}}r=r.concat(u);const i=new Set;for(const o of s){if(o%2===0){i.add(o/2);continue}if(o%2===0){i.add((o+1)/2);continue}i.add((o-1)/2)}s=Array.from(i)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(r=>this.bufferToHex(r))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(e.every(Number.isInteger)?r=[...e].sort((i,o)=>i===o?0:i>o?1:-1):r=e.map(i=>this.bufferIndexOf(this.leaves,i,this.sortLeaves)).sort((i,o)=>i===o?0:i>o?1:-1),!r.every(i=>i!==-1))throw new Error("Element does not exist in Merkle tree");const s=t.map(i=>this.bufferify(i)),n=[],u=[];for(let i=0;i<this.layers.length;i++){const o=this.layers[i];r=r.reduce((l,c)=>{if(!n.includes(o[c])){const h=this.getPairNode(o,c),m=s.includes(o[c])||s.includes(h);h&&u.push(!m),n.push(o[c]),n.push(h)}return l.push(c/2|0),l},[])}return u}verify(e,t,r){let s=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let n=0;n<e.length;n++){const u=e[n];let i=null,o=null;if(typeof u=="string")i=this.bufferify(u),o=!0;else if(Array.isArray(u))o=u[0]===0,i=this.bufferify(u[1]);else if(p.Buffer.isBuffer(u))i=u,o=!0;else if(u instanceof Object)i=this.bufferify(u.data),o=u.position==="left";else throw new Error("Expected node to be of type string or object");const l=[];this.isBitcoinTree?(l.push(P(s)),l[o?"unshift":"push"](P(i)),s=this.hashFn(this.concatenator(l)),s=P(this.hashFn(s))):this.sortPairs?p.Buffer.compare(s,i)===-1?(l.push(s,i),s=this.hashFn(this.concatenator(l))):(l.push(i,s),s=this.hashFn(this.concatenator(l))):(l.push(s),l[o?"unshift":"push"](i),s=this.hashFn(this.concatenator(l)))}return p.Buffer.compare(s,r)===0}verifyMultiProof(e,t,r,s,n){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,s,n);const i=Math.ceil(Math.log2(s));e=this.bufferify(e),r=r.map(f=>this.bufferify(f)),n=n.map(f=>this.bufferify(f));const o={};for(const[f,h]of this.zip(t,r))o[2**i+f]=h;for(const[f,h]of this.zip(this.getProofIndices(t,i),n))o[f]=h;let l=Object.keys(o).map(f=>Number(f)).sort((f,h)=>f-h);l=l.slice(0,l.length-1);let c=0;for(;c<l.length;){const f=l[c];if(f>=2&&{}.hasOwnProperty.call(o,f^1)){let h=[o[f-f%2],o[f-f%2+1]];this.sortPairs&&(h=h.sort(p.Buffer.compare));const m=h[1]?this.hashFn(this.concatenator(h)):h[0];o[f/2|0]=m,l.push(f/2|0)}c+=1}return!t.length||{}.hasOwnProperty.call(o,1)&&o[1].equals(e)}verifyMultiProofWithFlags(e,t,r,s){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const n=t.length,u=s.length,i=[];let o=0,l=0,c=0;for(let f=0;f<u;f++){const h=s[f]?o<n?t[o++]:i[l++]:r[c++],m=o<n?t[o++]:i[l++],y=[h,m].sort(p.Buffer.compare);i[f]=this.hashFn(this.concatenator(y))}return p.Buffer.compare(i[u-1],e)===0}verifyMultiProofForUnevenTree(e,t,r,s,n){e=this.bufferify(e),r=r.map(i=>this.bufferify(i)),n=n.map(i=>this.bufferify(i));const u=this.calculateRootForUnevenTree(t,r,s,n);return e.equals(u)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map(r=>r.map(s=>this.bufferToHex(s,!1))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let n=0;n<e[r].length;n++){const u={[e[r][n]]:null};if(t.length){u[e[r][n]]={};const i=t.shift(),o=Object.keys(i)[0];if(u[e[r][n]][o]=i[o],t.length){const l=t.shift(),c=Object.keys(l)[0];u[e[r][n]][c]=l[c]}}s.push(u)}t.push(...s)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return Le.asTree(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=e?.length||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,s){const n=this.zip(e,t).sort((f,h)=>{let[m]=f,[y]=h;return m-y}),u=n.map(f=>{let[h]=f;return h}),i=this.getProofIndicesForUnevenTree(u,r);let o=0;const l=[];for(let f=0;f<i.length;f++){const h=i[f],m=o;o+=h.length,l[f]=this.zip(h,s.slice(m,o))}const c=[n];for(let f=0;f<l.length;f++){const h=l[f].concat(c[f]).sort((d,T)=>{let[k]=d,[b]=T;return k-b}).map(d=>{let[,T]=d;return T}),m=c[f].map(d=>{let[T]=d;return T}),y=[...new Set(m.map(d=>d%2===0?d/2:d%2===0?(d+1)/2:(d-1)/2))],A=[];for(let d=0;d<y.length;d++){const T=y[d],k=h[d*2],b=h[d*2+1],x=b?this.hashFn(this.concatenator([k,b])):k;A.push([T,x])}c.push(A)}return c[c.length-1][0][1]}}function rt(a){return{startTimestamp:a.startTimestamp,maxClaimableSupply:a.maxClaimableSupply,supplyClaimed:a.supplyClaimed,merkleRoot:a.merkleRoot,pricePerToken:a.pricePerToken,currency:a.currency,quantityLimitPerTransaction:a.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:a.waitTimeInSecondsBetweenClaims||0}}function st(a){return{startTimestamp:a.startTimestamp,maxClaimableSupply:a.maxClaimableSupply,supplyClaimed:a.supplyClaimed,merkleRoot:a.merkleRoot,pricePerToken:a.pricePerToken,currency:a.currency,quantityLimitPerWallet:a.maxClaimablePerWallet,metadata:a.metadata||""}}function O(a,e){return a==="unlimited"?v:N(a,e)}async function ae(a){const t=Array.from({length:Math.ceil(a.length/25e3)},(n,u)=>a.slice(u*25e3,u*25e3+25e3)),r=[],s=await Promise.all(t.map(n=>Q.parseAsync(n)));for(const n of s)r.push(...n);return r}const Re=2;let W=(function(a){return a[a.V1=1]="V1",a[a.V2=2]="V2",a})({});class w{constructor(e,t,r,s,n){this.storage=e,this.shardNybbles=s,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=n,this.shards={},this.trees={}}static async fromUri(e,t){try{const r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return w.fromShardedMerkleTreeInfo(r,t)}catch{return}}static async fromShardedMerkleTreeInfo(e,t){return new w(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,s){switch(s){case W.V1:return X(["address","uint256"],[e.address,O(e.maxClaimable,t)]);case W.V2:return X(["address","uint256","uint256","address"],[e.address,O(e.maxClaimable,t),O(e.price||"unlimited",r),e.currencyAddress||B])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let s=e[r];return s===void 0&&(s=(await be(t,r)).decimals,e[r]=s),s}static async buildAndUpload(e,t,r,s,n){let u=arguments.length>5&&arguments[5]!==void 0?arguments[5]:Re;const i=await ae(e),o={};for(const b of i){const x=b.address.slice(2,2+u).toLowerCase();o[x]===void 0&&(o[x]=[]),o[x].push(b)}const l={},c=await Promise.all(Object.entries(o).map(async b=>{let[x,D]=b;return[x,new L(await Promise.all(D.map(async H=>{const ue=await w.fetchAndCacheDecimals(l,r,H.currencyAddress);return w.hashEntry(H,t,ue,n)})),F,{sort:!0}).getHexRoot()]})),f=Object.fromEntries(c),h=new L(Object.values(f),F,{sort:!0}),m=[];for(const[b,x]of Object.entries(o)){const D={proofs:h.getProof(f[b]).map(H=>"0x"+H.data.toString("hex")),entries:x};m.push({data:JSON.stringify(D),name:`${b}.json`})}const y=await s.uploadBatch(m),A=y[0].slice(0,y[0].lastIndexOf("/")),d=await s.upload(i),T={merkleRoot:h.getHexRoot(),baseUri:A,originalEntriesUri:d,shardNybbles:u,tokenDecimals:t,isShardedMerkleTree:!0},k=await s.upload(T);return{shardedMerkleInfo:T,uri:k}}async getProof(e,t,r){const s=e.slice(2,2+this.shardNybbles).toLowerCase();let n=this.shards[s];const u={};if(n===void 0)try{const f=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;n=this.shards[s]=await this.storage.downloadJSON(`${f}${s}.json`);const h=await Promise.all(n.entries.map(async m=>{const y=await w.fetchAndCacheDecimals(u,t,m.currencyAddress);return w.hashEntry(m,this.tokenDecimals,y,r)}));this.trees[s]=new L(h,F,{sort:!0})}catch{return null}const i=n.entries.find(f=>f.address.toLowerCase()===e.toLowerCase());if(!i)return null;const o=await w.fetchAndCacheDecimals(u,t,i.currencyAddress),l=w.hashEntry(i,this.tokenDecimals,o,r),c=this.trees[s].getProof(l).map(f=>"0x"+f.data.toString("hex"));return we.parseAsync({...i,proof:c.concat(n.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}}async function Me(a,e,t,r,s,n){if(!t)return null;const u=t[e];if(u){const i=await s.downloadJSON(u);if(i.isShardedMerkleTree&&i.merkleRoot===e)return await(await w.fromShardedMerkleTreeInfo(i,s)).getProof(a,r,n);const o=await te.parseAsync(i);if(e===o.merkleRoot)return o.claims.find(l=>l.address.toLowerCase()===a.toLowerCase())||null}return null}function at(a){return{startTimestamp:a.startTimestamp,maxClaimableSupply:a.maxClaimableSupply,supplyClaimed:a.supplyClaimed,merkleRoot:a.merkleRoot.toString(),pricePerToken:a.pricePerToken,currency:a.currency,maxClaimablePerWallet:a.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:a.waitTimeInSecondsBetweenClaims}}function nt(a){return{startTimestamp:a.startTimestamp,maxClaimableSupply:a.maxClaimableSupply,supplyClaimed:a.supplyClaimed,merkleRoot:a.merkleRoot.toString(),pricePerToken:a.pricePerToken,currency:a.currency,maxClaimablePerWallet:a.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:a.metadata}}async function Ue(a,e,t,r,s){const n=a.getSigner(),u=a.getProvider(),i=(await Se(async()=>{const{default:m}=await import("./index-BFJltGNr.js").then(y=>y.eF);return{default:m}},__vite__mapDeps([0,1]))).default,o=new Te(n||u,e,i,a.options,a.storage),l=await a.getSignerAddress(),c=a.address,f=await o.read("allowance",[l,c]),h=C.from(t).mul(C.from(r)).div(N("1",s));f.lt(h)&&await o.sendTransaction("approve",[c,f.add(h)])}async function it(a,e,t,r,s,n,u,i,o){let l=O(t.maxClaimablePerWallet,s),c=[V([0],32)],f=t.price,h=t.currencyAddress;try{if(!t.merkleRootHash.toString().startsWith(B)){const d=await Me(a,t.merkleRootHash.toString(),await r(),n.getProvider(),u,o);if(d)c=d.proof,l=d.maxClaimable==="unlimited"?v:N(d.maxClaimable,s),f=d.price===void 0||d.price==="unlimited"?v:await re(n.getProvider(),d.price,d.currencyAddress||B),h=d.currencyAddress||B;else if(o===W.V1)throw new Error("No claim found for this address")}}catch(d){if(d?.message==="No claim found for this address")throw d;console.warn("failed to check claim condition merkle root hash, continuing anyways",d)}const m=await n.getCallOverrides()||{},y=f.toString()!==v.toString()?f:t.price,A=h!==B?h:t.currencyAddress;return y.gt(0)&&(he(A)?m.value=C.from(y).mul(e).div(N("1",s)):i&&await Ue(n,A,y,e,s)),{overrides:m,proofs:c,maxClaimable:l,price:y,currencyAddress:A,priceInProof:f,currencyAddressInProof:h}}const De=M({name:I(),symbol:I(),decimals:xe()}),Fe=De.extend({value:g,displayValue:I()}),qe=M({name:I().optional()}).catchall(Pe()),Z=M({startTime:se,currencyAddress:I().default($),price:z.default(0),maxClaimableSupply:R,maxClaimablePerWallet:R,waitInSeconds:J.default(0),merkleRootHash:ge.default(V([0],32)),snapshot:ye(Q).nullable(),metadata:qe.optional()}),je=ce(Z),ne=Z.extend({availableSupply:R,currentMintSupply:R,currencyMetadata:Fe.default({value:C.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:g,waitInSeconds:g,startTime:g.transform(a=>new Date(a.toNumber()*1e3)),snapshot:Q.optional().nullable()});async function We(a,e,t,r,s){const n=await ae(a),u=n.map(l=>l.address);if(new Set(u).size<u.length)throw new Be;const o=await w.buildAndUpload(n,e,t,r,s);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}function ze(a,e){const t=C.from(a),r=C.from(e);return t.eq(r)?0:t.gt(r)?1:-1}async function $e(a,e,t,r,s){const n=[];return{inputsWithSnapshots:await Promise.all(a.map(async i=>{if(i.snapshot&&i.snapshot.length>0){const o=await We(i.snapshot,e,t,r,s);n.push(o),i.merkleRootHash=o.merkleRoot}else i.merkleRootHash=V([0],32);return i})),snapshotInfos:n}}async function Ve(a,e,t,r){const s=a.currencyAddress===B?$:a.currencyAddress,n=O(a.maxClaimableSupply,e),u=O(a.maxClaimablePerWallet,e);let i;return a.metadata&&(typeof a.metadata=="string"?i=a.metadata:i=await r.upload(a.metadata)),{startTimestamp:a.startTime,maxClaimableSupply:n,supplyClaimed:0,maxClaimablePerWallet:u,pricePerToken:await re(t,a.price,s),currency:s,merkleRoot:a.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:a.waitInSeconds||0,metadata:i}}async function ot(a,e,t,r,s){const{inputsWithSnapshots:n,snapshotInfos:u}=await $e(a,e,t,r,s),i=await je.parseAsync(n),o=(await Promise.all(i.map(l=>Ve(l,e,t,r)))).sort((l,c)=>ze(l.startTimestamp,c.startTimestamp));return{snapshotInfos:u,sortedConditions:o}}async function Je(a,e,t){if(!e)return null;const r=e[a];if(r){const s=await t.downloadJSON(r);if(s.isShardedMerkleTree&&s.merkleRoot===a)return(await w.fromUri(r,t))?.getAllEntries()||null;{const n=await te.parseAsync(s);if(a===n.merkleRoot)return n.claims.map(u=>({address:u.address,maxClaimable:u.maxClaimable,price:u.price,currencyAddress:u.currencyAddress}))}}return null}function E(a,e){return a.toString()===v.toString()?"unlimited":j(a,e)}async function ut(a,e,t,r,s,n){const u=await fe(t,a.currency,a.pricePerToken),i=E(a.maxClaimableSupply,e),o=E(a.maxClaimablePerWallet,e),l=E(C.from(a.maxClaimableSupply).sub(a.supplyClaimed),e),c=E(a.supplyClaimed,e);let f;return a.metadata&&(f=await s.downloadJSON(a.metadata)),ne.parseAsync({startTime:a.startTimestamp,maxClaimableSupply:i,maxClaimablePerWallet:o,currentMintSupply:c,availableSupply:l,waitInSeconds:a.waitTimeInSecondsBetweenClaims?.toString(),price:C.from(a.pricePerToken),currency:a.currency,currencyAddress:a.currency,currencyMetadata:u,merkleRootHash:a.merkleRoot,snapshot:n?await Je(a.merkleRoot,r,s):void 0,metadata:f})}async function lt(a,e,t){if(a>=t.length)throw Error(`Index out of bounds - got index: ${a} with ${t.length} conditions`);const r=t[a].currencyMetadata.decimals,s=t[a].price,n=j(s,r),u=await Z.parseAsync({...t[a],price:n,...e}),i=await ne.parseAsync({...u,price:s});return t.map((o,l)=>{let c;l===a?c=i:c=o;const f=j(c.price,r);return{...c,price:f}})}let ft=(function(a){return a.NotEnoughSupply="There is not enough supply to claim.",a.AddressNotAllowed="This address is not on the allowlist.",a.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",a.ClaimPhaseNotStarted="Claim phase has not started yet.",a.AlreadyClaimed="You have already claimed the token.",a.WrongPriceOrCurrency="Incorrect price or currency.",a.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",a.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",a.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",a.NoClaimConditionSet="There is no claim condition set.",a.NoWallet="No wallet connected.",a.Unknown="No claim conditions found.",a})({});function Qe(a){if(a===void 0){const e=Buffer.alloc(16);return de({},e),K(me(e.toString("hex")))}else return K(a)}const ie=M({to:Y.refine(a=>a.toLowerCase()!==B,{message:"Cannot create payload to mint to zero address"}),price:z.default(0),currencyAddress:le.default($),mintStartTime:se,mintEndTime:Ce,uid:I().optional().transform(a=>Qe(a)),primarySaleRecipient:Y.default(B)}),Ze=ie.extend({quantity:z}),ct=Ze.extend({mintStartTime:g,mintEndTime:g}),G=ie.extend({metadata:U,royaltyRecipient:I().default(B),royaltyBps:pe.default(0)}),oe=G.extend({metadata:U.default(""),uri:I(),royaltyBps:g,mintStartTime:g,mintEndTime:g}),Ge=G.extend({metadata:U.default(""),quantity:J}),ht=Ge.extend({tokenId:J}),pt=oe.extend({tokenId:g,quantity:g}),dt=G.extend({metadata:U.default(""),quantity:g.default(1)}),mt=oe.extend({quantity:g.default(1)}),yt=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],gt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],bt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],wt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];var q,_;function Ye(){return _||(_=1,q=function a(e,t){if(e===t)return!0;if(e&&t&&typeof e=="object"&&typeof t=="object"){if(e.constructor!==t.constructor)return!1;var r,s,n;if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(s=r;s--!==0;)if(!a(e[s],t[s]))return!1;return!0}if(e.constructor===RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();if(n=Object.keys(e),r=n.length,r!==Object.keys(t).length)return!1;for(s=r;s--!==0;)if(!Object.prototype.hasOwnProperty.call(t,n[s]))return!1;for(s=r;s--!==0;){var u=n[s];if(!a(e[u],t[u]))return!1}return!0}return e!==e&&t!==t}),q}var Ke=Ye();const St=ee(Ke);export{ie as B,ft as C,bt as M,ht as S,Ue as a,pt as b,O as c,St as d,rt as e,Me as f,st as g,it as h,W as i,Ze as j,ct as k,at as l,yt as m,nt as n,dt as o,ot as p,mt as q,Qe as r,gt as s,ut as t,lt as u,wt as v};
