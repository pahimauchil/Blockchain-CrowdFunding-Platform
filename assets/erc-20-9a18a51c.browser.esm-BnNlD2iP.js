import{aF as S,bA as M,ao as i,a1 as n,a2 as p,ax as E,bB as W,bC as b,bD as y,bE as w,bF as C,bG as B,al as f,$ as N,bb as _,bH as A,as as v,ay as O}from"./index-BFJltGNr.js";import{a as l}from"./assertEnabled-d1700f0b.browser.esm-Du5v_594.js";import{d as h,a as F}from"./contract-appuri-5c40af52.browser.esm-Cll9E6Ih.js";import{D as R}from"./drop-claim-conditions-e6f2abbf.browser.esm-CtWVWtsV.js";import{s as z}from"./setErc20Allowance-7f76f677.browser.esm-C2WcXHxg.js";import{j as I,k as D,m as V}from"./index-CcV9U-cR.js";async function U(m,t){const r=await m.read("decimals",[]);return A(v.parse(t),r)}class K{featureName=y.name;constructor(t,r){this.erc20=t,this.contractWrapper=r}tokens=n(async t=>p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]}));from=n(async(t,r)=>p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([i(t),this.erc20.normalizeAmount(r)])}))}class L{featureName=w.name;constructor(t,r,a){this.erc20=t,this.contractWrapper=r,this.storage=a;const e=new F(this.contractWrapper,O,this.storage);this.conditions=new R(this.contractWrapper,e,this.storage)}to=n(async(t,r,a)=>{const e=await this.erc20.normalizeAmount(r);return await this.conditions.getClaimTransaction(t,e,a)})}class k{constructor(t,r,a){this.erc20=t,this.contractWrapper=r,this.storage=a,this.claim=new L(this.erc20,this.contractWrapper,this.storage)}}class G{featureName=b.name;constructor(t,r){this.erc20=t,this.contractWrapper=r}to=n(async t=>{const r=new E(this.contractWrapper),e=(await Promise.all(t.map(s=>Promise.all([i(s.toAddress),this.erc20.normalizeAmount(s.amount)])))).map(s=>{let[c,u]=s;return r.encode("mintTo",[c,u])});return p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e]})})}class H{featureName=W.name;constructor(t,r){this.erc20=t,this.contractWrapper=r,this.batch=this.detectErc20BatchMintable()}to=n(async(t,r)=>await this.getMintTransaction(t,r));async getMintTransaction(t,r){return p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([i(t),this.erc20.normalizeAmount(r)])})}detectErc20BatchMintable(){if(h(this.contractWrapper,"ERC20BatchMintable"))return new G(this.erc20,this.contractWrapper)}}class j{featureName=C.name;constructor(t,r){this.contractWrapper=t,this.roles=r}mint=n(async t=>{const r=t.payload,a=t.signature,[e,s]=await Promise.all([this.mapPayloadToContractStruct(r),this.contractWrapper.getCallOverrides()]);return await z(this.contractWrapper,f.from(e.price),r.currencyAddress,s),p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[e,a],overrides:s})});mintBatch=n(async t=>{const r=await Promise.all(t.map(c=>this.mapPayloadToContractStruct(c.payload))),a=t.map((c,u)=>{const g=r[u],o=c.signature,d=c.payload.price;if(f.from(d).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:g,signature:o}}),e=new E(this.contractWrapper),s=a.map(c=>e.encode("mintWithSignature",[c.message,c.signature]));return p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s]})});async verify(t){const r=t.payload,a=t.signature,e=await this.mapPayloadToContractStruct(r);return(await this.contractWrapper.read("verify",[e,a]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress());const[r,a,e]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map(o=>I.parseAsync(o)))]),s=this.contractWrapper.getSigner();N(s);const c=await Promise.all(e.map(o=>D.parseAsync(o))),u=await Promise.all(c.map(o=>this.mapPayloadToContractStruct(o))),g=await Promise.all(u.map(o=>this.contractWrapper.signTypedData(s,{name:a,version:"1",chainId:r,verifyingContract:this.contractWrapper.address},{MintRequest:V},o)));return e.map((o,d)=>{const T=c[d],P=g[d];return{payload:T,signature:P.toString()}})}async mapPayloadToContractStruct(t){const[r,a]=await Promise.all([_(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),e=A(t.quantity,a);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:e,price:r,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class Y{featureName=S.name;get chainId(){return this._chainId}constructor(t,r,a){this.contractWrapper=t,this.storage=r,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=a}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await M(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await i(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){const[r,a]=await Promise.all([this.contractWrapper.getSignerAddress(),i(t)]);return await this.allowanceOf(r,a)}async allowanceOf(t,r){const a=await Promise.all([i(t),i(r)]);return await this.getValue(await this.contractWrapper.read("allowance",a))}transfer=n(async(t,r)=>p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([i(t),this.normalizeAmount(r)])}));transferFrom=n(async(t,r,a)=>p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([i(t),i(r),this.normalizeAmount(a)])}));setAllowance=n(async(t,r)=>p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([i(t),this.normalizeAmount(r)])}));transferBatch=n(async t=>{const r=new E(this.contractWrapper),a=(await Promise.all(t.map(e=>Promise.all([this.normalizeAmount(e.amount),i(e.toAddress)])))).map(e=>{let[s,c]=e;return r.encode("transfer",[c,s])});return p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a]})});mint=n(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintTo=n(async(t,r)=>l(this.mintable,W).to.prepare(t,r));async getMintTransaction(t,r){return l(this.mintable,W).getMintTransaction(t,r)}mintBatchTo=n(async t=>l(this.mintable?.batch,b).to.prepare(t));burn=n(async t=>l(this.burnable,y).tokens.prepare(t));burnFrom=n(async(t,r)=>l(this.burnable,y).from.prepare(t,r));claim=n(async(t,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r));claimTo=n(async(t,r,a)=>l(this.droppable?.claim,w).to.prepare(t,r,a));get claimConditions(){return l(this.droppable?.claim,w).conditions}get signature(){return l(this.signatureMintable,C)}async normalizeAmount(t){return U(this.contractWrapper,t)}async getValue(t){return await B(this.contractWrapper.getProvider(),this.getAddress(),f.from(t))}detectErc20Mintable(){if(h(this.contractWrapper,"ERC20"))return new H(this,this.contractWrapper)}detectErc20Burnable(){if(h(this.contractWrapper,"ERC20Burnable"))return new K(this,this.contractWrapper)}detectErc20Droppable(){if(h(this.contractWrapper,"ERC20ClaimConditionsV1")||h(this.contractWrapper,"ERC20ClaimConditionsV2")||h(this.contractWrapper,"ERC20ClaimPhasesV1")||h(this.contractWrapper,"ERC20ClaimPhasesV2"))return new k(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if(h(this.contractWrapper,"ERC20SignatureMintable"))return new j(this.contractWrapper)}}export{Y as E,j as a};
